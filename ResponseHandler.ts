import { stringify } from "querystring";
import { DatabaseManager } from "./DatabaseManager";
import { Login } from "./LoginHandler";
import { deepCopy } from "./Utility"; 
const fs = require('fs');


class ItemData{
    public ItemType:string;
    public Options:Array<any>;
    public Values:Array<any>;
    constructor(_ItemType){
        this.ItemType = _ItemType;
        this.Options = [];
    }
    public AddOptions(_option:any, values:Array<string>){
        this.Options.push({[_option]: values});
        //console.log(this.Options);
    }
    public Print(){
        console.log("ItemType: " + this.ItemType);
        console.log("Options: " + JSON.stringify(this.Options));
    }
}


//TODO Need to implement responsice error handling so a single bug doesnt bring down the server
//     Try catch and using base state should be able to keep the server from crashing
//  https://stackoverflow.com/questions/34834151/how-to-catch-errors-when-rendering-ejs-view-node-js
// Possibly a good method of error handling
class  ResponseHandler{
    DBController: DatabaseManager;

    //TODO Need to make sure every Button is as variable as CancelButton
    protected PageState:{
        LoginForm:boolean,
        Switch:{On:boolean, Off:boolean},
        PopUp:boolean,
        Form:{Edit:boolean, Add:boolean},
        CurrentRenderTarget:string,
        Title:string,
        _Action:string,
        CancelButton:{Name?:string, Value?:boolean},
        AllowedActions:any,
        DataBaseAcess:any
        };
    readonly BasePageState: any;


    protected ItemInformation: any;
    private Items: Array<any>;
    protected ItemTypes: Array<string>;
    protected ItemOptions: any;
    protected ItemValues: Array<string>
    protected Column: Array<string>;
    private AutoGeneratedClassColumn:string;
    protected ItemDataArray:Array<ItemData>;

    private ClassName: string;
    private TableName: string;
    private CACIndex:number; //Class Auto Column Index: This is the number of columns generated by the class inheriting from Response handler
    protected User:Login;
    protected Username:string;

    protected Permission: {
        Low: number,
        Mid:number,
        High:number
    }
    
    
    constructor(DBController: DatabaseManager, User:Login, ClassName, TableName=undefined, ClassAutoColumn:string = "", CACIndex:number = 0){
        this.DBController = DBController;
        this.User = User;
        this.ClassName = ClassName;
        this.TableName = TableName;
        this.AutoGeneratedClassColumn = ClassAutoColumn;
        this.CACIndex = CACIndex;
        this.Items = []; //Used to store items in Object format from JSON file
        this.ItemTypes = []; //Used to Store Item Types
        this.ItemOptions = []; //Used to store Option Keys
        this.ItemDataArray = []; //Used to Store Instances of ItemData Class
        this.BasePageState = {
            LoginForm:false,
            Switch:{On:true, Off:false},
            PopUp:false,
            Form:{Edit:false, Add:false},
            CurrentRenderTarget:"index",
            Title:"Database",
            _Action:"/",
            CancelButton:{}
            };
        this.PageState = deepCopy(this.BasePageState);
        
        this.Permission = {
            Low:0,
            Mid:1,
            High:2
        }
        
    }

    public SetCurrentRenderTarget(name:string){
        this.PageState.CurrentRenderTarget = name;
    }

    //Resets a specific Value in PageState to the base value
    public ResetPageState(ValueToReset:string) : void {
        this.PageState[ValueToReset] = this.BasePageState[ValueToReset];
    }
    /*
    *                               Login Initialization
    *   This will be called when a login has been achieved so that allowed actions can be updated
    */
    public InitLogin(req, res, IsLogin:boolean) : void{
        if(req.session.loggedin){
            if(this.User.PermissionLevel(req, this.Permission.High)){
                Object.keys(req.session.AllowedActions).forEach(key => {
                    req.session.AllowedActions[key] = true;
                    });
            }
            if(this.User.PermissionLevel(req, this.Permission.Mid)){
                req.session.AllowedActions.ViewLogs = true;
                req.session.AllowedActions.Create = true;
                req.session.AllowedActions.Update = true;
            }
            if(this.User.PermissionLevel(req, this.Permission.Low)){
                req.session.AllowedActions.ViewLogs = true;
            }
        }
        console.log(req.session.AllowedActions);
    }
    /*
    *   Basic Render Page function that Gives PageData from the child and PageState to handle Templating of the page
    */
    public RenderPage(req, res, PageData){
        console.log(PageData.Warehouse);
        var BuildRenderTarget = `pages/${this.PageState.CurrentRenderTarget}`;
        res.render(BuildRenderTarget, {PageState:this.PageState, Data:PageData}, function(err, html) {
            if(err){
                console.log(err);
                res.sendFile(__dirname + "/public/404.html");
            }else{
                res.send(html);
            }
        });
    }
    /*
    *   Basic Get and Post functions. Ment to be overriden with childerens specfic get and post
    */
    _Get(req, res, Data) : void{
        this.RenderPage(req, res, Data);
    }
    _Post(req, res, Data) : void{
        this.RenderPage(req, res, Data)
    }
    //TODO Need to create utility file that will contain all of the utility functions, need to put deep copy and mergearray into that instead of sitting here

    /*
    *   This Function Does a few things
    *   1. This function gets the different item types and Options
    *   2. It gets all current columns if there is any, it then checks to see if the there are any new items that need to be added
    *   3. It then builds the strings that need to be added together and the ItemData objects
    *   4. Finally it either creates a new table or it doubles checkes these are new items and then updates the table
    */
    async UpdateItemInformation(newValue:any){
        if(newValue === undefined){
            return;
        }
        /*
        *   This Blob here Gets the Names of the Objects and the objects themselves
        */
        this.Items = newValue;
        for(var _node in newValue){
            this.ItemTypes = Object.keys(newValue);            
        }
        /*
        * Retrieve all Item Options
        */
        for(var Option in this.Items){ //Got All Options
            if(typeof this.Items[Option] === 'object'){            
                Object.keys(this.Items[Option]).forEach((item) =>{
                    if(!this.ItemOptions.includes(item)){
                        this.ItemOptions.push(item);
                    }
                });
            }
        }
        /*
        *   Now I need to get all current columns
        *   Then check each column to see if it already has the option in it
        */
        this.DBController.getColumns(this.TableName).then((result) => { //Got all new options that table didnt have previously
            var newItems = []; //Stores all new Item
            for(var i = 0; i < this.ItemOptions.length; i++){
                var NewItem = true; //Boolean check for new items
                for(var j = 1+this.CACIndex; j < result.length; j++){
                    if(this.ItemOptions[i] == result[j].name){//If it is in the Table then continue;
                        NewItem = false;
                        continue;
                    } 
                    if(j == result.length - 1){ //If its the end of the loop and they arent equal
                        if(NewItem){ //And it is a new item
                            newItems.push(this.ItemOptions[i]); //Add it to the list
                        }
                    }
                }
            }
            if(newItems.length == 0){
                newItems = this.ItemOptions;
            }
            /*
            *   Now I need To use the the full objects and parse it using the Itemtype and the Options it has to grab it's values
            *   I need to grab the values so I know what type the options are
            */
            var ColumnBuilder = [];
            ColumnBuilder.push(this.AutoGeneratedClassColumn); //Add the Class based column information
            for(var type in  this.ItemTypes){ //Loop Through item types
                var CurrentItem = new ItemData(this.ItemTypes[type]); //Initialize a new Item
                var Options = Object.keys(this.Items[this.ItemTypes[type]]) //Get all of the keys of the current item type
                for(var _node_one in Options){ //Loop through the Options found from the keys
                    var SavedValues = []; //Options Values will be stored temporarily in this array
                    for(var item in newItems){ //Loop through the newitem list 
                       if(Options[_node_one] == newItems[item]){ //Check if we found a new item
                            if(typeof this.Items[this.ItemTypes[type]][Options[_node_one]] == 'object'){ //If the item is a object
                                for(var values in this.Items[this.ItemTypes[type]][Options[_node_one]]){ //Loop through and get all of the variables from it
                                    SavedValues.push(this.Items[this.ItemTypes[type]][Options[_node_one]][values]); //Push the variables found to SavedValues
                                }
                            }else{
                                SavedValues.push(this.Items[this.ItemTypes[type]][Options[_node_one]]) //If its not a object push the values to savedValues
                            }
                            if(Number.isInteger(SavedValues[0])){ //Check if it is a number
                                ColumnBuilder.push(`${Options[_node_one]}`, `INTEGER`);
                            }else if(typeof SavedValues[0] == "string"){ //check if it is a string
                                ColumnBuilder.push(`${Options[_node_one]}`, `TEXT`);
                            }else if(typeof SavedValues[0] == 'boolean'){ //Check if it is a boolean
                                ColumnBuilder.push(`${Options[_node_one]}`, `INTEGER`);
                            }
                            CurrentItem.AddOptions(Options[_node_one], SavedValues); //Add the options to the Item
                        }
                    }
                }
                this.ItemDataArray.push(CurrentItem); //Push the Item to the Itemdataarray and restart
            }
            this.Column = ColumnBuilder; //Format for columnbuilder is: 0 = AutoGenerated SKU 1 = first Built column 2 = column definition 3 = second column 4 = column definition
            // so the to use columnbuild you need a for(let i = 1; i < ColumnBuilder.length; i += 2)
            // This alllows you to skip over the auto generated and access the columns. to get the deinitions you just need to add 1 to the index

            /*
            *   Build or Alter the Table with the options
            */
            var Dot = this.AutoGeneratedClassColumn == "" ? "" : ", ";
            var TableColumn = this.Column[0];
            if(result.length == 0){ //If no table exist
                for(let i = 1; i < this.Column.length; i += 2){
                    TableColumn += `${Dot}${this.Column[i]} ${this.Column[i+1]}`;
                }
                this.DBController.createTable(this.TableName, this.ClassName, TableColumn).then((result)=> { //Create Sable Table
                })
            }else{ //If we are updating a existing table
                var newItemArray = [];
                    var Check = true;
                    for(let j = 0; j < newItems.length; j++){ //This section is just to double check these are new items, we will also need to find items to ..
                        for(let i = 1+this.CACIndex; i < result.length; i++){ //    delete in the future
                        if(result[i].name == newItems[j]){
                            Check = false;
                            break;
                        }
                        if(i == result.length - 1){
                            if(Check == true){
                                var leave = false;
                                for(var item in newItemArray){
                                   if(newItemArray[item] === newItems[j]){
                                    leave = true;
                                   } 
                                }
                                if(leave){
                                    break;
                                }
                                newItemArray.push(newItems[j]);
                                }
                            }
                        }
                    }
                if(newItemArray.length > 0){
                    for(var item in newItemArray){
                        for(let i = 1; i < this.Column.length; i += 2){
                            if(newItemArray[item] == this.Column[i]){
                                 this.DBController.updateTable(this.TableName, `${this.Column[i]} ${this.Column[i+1]}`);
                            }
                        }
                    }
                }
            }
        })
    }
    /*
    *   Called in constructor of child class. Starts the watch event for the file
    *   Calls a callback to handle changes to file
    */
    public ParseJson(FilePath:string, callback:Function) : void{
        let ParsedData: any;
        try{
            let rawdata = fs.readFileSync(FilePath);
            ParsedData = JSON.parse(rawdata);
            this.UpdateItemInformation(ParsedData);
        }catch(e){
            console.log(`Error: ${e} | @${FilePath}`);
            return;
        }
        fs.watchFile(FilePath, {
            bigint: false,
            persistent: true,
            interval: 500,
          },(curr, prev) => { //Watches specfied file
            try{
                let rawdata = fs.readFileSync(FilePath);
                let ParsedData = JSON.parse(rawdata);
                callback(ParsedData); //Callback to handle changes after
            }catch(e){
                console.log(`Error: ${e} | @${FilePath}`);
            }
        })
    }


     

}

export {ResponseHandler};