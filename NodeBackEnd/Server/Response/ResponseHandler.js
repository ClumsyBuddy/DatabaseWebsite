var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ItemData } from "./ItemData.js";
//const fs = require('fs');
import { readFileSync, watchFile } from "fs";
//TODO Need to implement responsice error handling so a single bug doesnt bring down the server
//     Try catch and using base state should be able to keep the server from crashing
//  https://stackoverflow.com/questions/34834151/how-to-catch-errors-when-rendering-ejs-view-node-js
// Possibly a good method of error handling
class ResponseHandler {
    /**
     *
     * @param {DataBaseManager}DBController
     * @param User
     * @param io
     * @param options
     */
    constructor(DBController, User, io, options) {
        this.DBController = DBController;
        this.User = User;
        this.io = io;
        this.ClassName = (options === null || options === void 0 ? void 0 : options.ClassName) === undefined ? "" : options.ClassName;
        this.TableName = (options === null || options === void 0 ? void 0 : options.TableName) === undefined ? "" : options.TableName;
        this.AutoGeneratedClassColumn = (options === null || options === void 0 ? void 0 : options.ClassAutoColumn) === undefined ? "" : options.ClassAutoColumn;
        this.CACIndex = (options === null || options === void 0 ? void 0 : options.CACIndex) === undefined ? 0 : options.CACIndex;
        this.Items = []; //Used to store items in Object format from JSON file
        this.ItemTypes = []; //Used to Store Item Types
        this.ItemOptions = []; //Used to store Option Keys
        this.ItemDataArray = []; //Used to Store Instances of ItemData Class
    }
    SetCurrentRenderTarget(req, res, name) {
        req.session.PageState.CurrentRenderTarget = name;
    }
    ReturnSearchResults(_Query = "") {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.DBController.getAll(this.TableName).then((result) => {
                let ProductList = _Query === "" ? result : []; //If we have no query then we can just get all results
                if (ProductList.length == 0) { //This section checks any products options matches the Query
                    var FoundItemArray = [];
                    var Query = _Query.split(" ");
                    for (var item in result) {
                        var Match = 0;
                        for (var queries in Query) {
                            if (result[item].sku.toLowerCase().includes(Query[queries].toLowerCase()) || result[item].brand.toLowerCase().includes(Query[queries].toLowerCase())) {
                                Match++;
                                continue;
                            }
                            for (var Data in this.ItemDataArray) {
                                var Options = this.ItemDataArray[Data].Options;
                                for (var O in Options) {
                                    if (typeof Options[O] === 'object') {
                                        for (var i in Options[O]) {
                                            if (result[item][i] == null || result[item][i] == undefined) {
                                                continue;
                                            }
                                            var ResultString = result[item][i].toLowerCase();
                                            if (ResultString.includes(Query[queries].toLowerCase())) {
                                                Match++;
                                            }
                                        }
                                    }
                                    else {
                                        if (result[item][Options[O]] == null || result[item][Options[O]] == undefined) {
                                            continue;
                                        }
                                        if (result[item][Options[O]].toLowerCase().includes(Query[queries].toLowerCase())) {
                                            Match++;
                                        }
                                    }
                                }
                            }
                        }
                        if (Match == Query.length) {
                            FoundItemArray.push(result[item]);
                        }
                    }
                    for (let i = 0; i < FoundItemArray.length; i++) {
                        for (let j = 0; j < FoundItemArray.length; j++) {
                            if (i == j) {
                                continue;
                            }
                            if (FoundItemArray[i].key == FoundItemArray[j].key) {
                                FoundItemArray.splice(j, 1);
                            }
                        }
                    }
                    return FoundItemArray;
                }
                else {
                    return result;
                }
            });
        });
    }
    UpdateItem(Columns, Values, key) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < Columns.length; i++) {
                yield this.DBController.update("Sable", Columns[i], Values[i], key);
            }
            return yield this.GetItemById("Sable", key);
        });
    }
    AddItem(ItemObject = {}, name) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Object.length === 0) {
                console.log("Empty Object"); //Double checking for any errors
                return;
            }
            if (!ItemObject.sku) {
                console.log("not SKU Given");
                return;
            }
            if (!ItemObject.brand) {
                console.log("No Brand Given");
                return;
            }
            let ItemAlreadyExist = yield this.DBController.getAll("Sable").then((result) => {
                for (let i = 0; i < result.length; i++) {
                    if (result[i].sku === ItemObject.sku && result[i].brand === ItemObject.brand) {
                        console.log("This already Exist");
                        return true;
                    }
                }
                return false;
            });
            if (ItemAlreadyExist === true) { //If the item already exist return
                return { ItemAlreadyExist: ItemAlreadyExist };
            }
            const keys = Object.keys(ItemObject); //Get all keys
            let QuestionMarkString = ""; //We need the question marks for the SQL query ei. (SELECT * FROM Sable WHERE id = ?)[parameters]
            for (let i = 0; i < keys.length; i++) {
                if (i === keys.length - 1) {
                    QuestionMarkString += "?";
                }
                else {
                    QuestionMarkString += "?,";
                }
            }
            let Columns = "";
            let Col_Values = [];
            keys.forEach((value, i) => {
                if (typeof ItemObject[value] === "string") {
                    Columns += value;
                    if (ItemObject[value][ItemObject[value].length - 1] === ",") {
                        ItemObject[value] = ItemObject[value].slice(0, ItemObject[value].length - 1);
                    }
                    Col_Values.push(ItemObject[value].replace(" ", ""));
                }
                else {
                    Columns += value.toString();
                    if (ItemObject[value][ItemObject[value].length - 1] === ",") {
                        ItemObject[value] = ItemObject[value].slice(0, ItemObject[value].length - 1);
                    }
                    Col_Values.push(ItemObject[value].toString());
                }
                if (i !== keys.length - 1) {
                    Columns += ","; //If we are not at the end add a comma between each column
                }
            });
            console.log("Columns: " + Columns);
            console.log("Column Values: ", Col_Values);
            let id = yield this.DBController.create("Sable", Columns, QuestionMarkString, Col_Values); //Create the item and return the id (aka the key)
            return { id: id.id, ItemAlreadyExist: false }; //return the id and that the item didnt exist
        });
    }
    GetItemById(DB, id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.DBController.getById(DB, id);
        });
    }
    DeleteItem(name, key) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.DBController.delete(name, key);
            if ((yield this.DBController.getById(name, key)) === undefined) {
                return true;
            }
            return false;
        });
    }
    GetAllProducts(name, req) {
        return __awaiter(this, void 0, void 0, function* () {
            var ProductList = [];
            yield this.DBController.getAll(name).then((result) => {
                ProductList = result;
                if (req !== undefined) {
                    req.session.PageData.ProductList = ProductList;
                }
            });
            return ProductList;
        });
    }
    get ItemData() {
        return this.ItemDataArray;
    }
    /*
    *   This Function Does a few things
    *   1. This function gets the different item types and Options
    *   2. It gets all current columns if there is any, it then checks to see if the there are any new items that need to be added
    *   3. It then builds the strings that need to be added together and the ItemData objects
    *   4. Finally it either creates a new table or it doubles checkes these are new items and then updates the table
    */
    UpdateItemInformation(newValue) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ItemDataArray = [];
            if (newValue === undefined) {
                return;
            }
            /*
            *   This Blob here Gets the Names of the Objects and the objects themselves
            */
            this.Items = newValue;
            for (var _node in newValue) {
                this.ItemTypes = Object.keys(newValue);
            }
            /*
            * Retrieve all Item Options
            */
            for (var Option in this.Items) { //Got All Options
                if (typeof this.Items[Option] === 'object') {
                    Object.keys(this.Items[Option]).forEach((item) => {
                        if (!this.ItemOptions.includes(item)) {
                            this.ItemOptions.push(item);
                        }
                    });
                }
            }
            /*
            *   Now I need to get all current columns
            *   Then check each column to see if it already has the option in it
            */
            this.DBController.getColumns(this.TableName).then((result) => {
                var newItems = []; //Stores all new Item
                for (var i = 0; i < this.ItemOptions.length; i++) {
                    var NewItem = true; //Boolean check for new items
                    for (var j = 1 + this.CACIndex; j < result.length; j++) {
                        if (this.ItemOptions[i] == result[j].name) { //If it is in the Table then continue;
                            NewItem = false;
                            continue;
                        }
                        if (j == result.length - 1) { //If its the end of the loop and they arent equal
                            if (NewItem) { //And it is a new item
                                newItems.push(this.ItemOptions[i]); //Add it to the list
                            }
                        }
                    }
                }
                if (newItems.length == 0) {
                    newItems = this.ItemOptions;
                }
                /*
                *   Now I need To use the the full objects and parse it using the Itemtype and the Options it has to grab it's values
                *   I need to grab the values so I know what type the options are
                */
                var ColumnBuilder = [];
                ColumnBuilder.push(this.AutoGeneratedClassColumn); //Add the Class based column information
                for (var type in this.ItemTypes) { //Loop Through item types
                    var CurrentItem = new ItemData(this.ItemTypes[type]); //Initialize a new Item
                    var Options = Object.keys(this.Items[this.ItemTypes[type]]); //Get all of the keys of the current item type
                    for (var _node_one in Options) { //Loop through the Options found from the keys
                        var SavedValues = []; //Options Values will be stored temporarily in this array
                        for (var item in newItems) { //Loop through the newitem list 
                            if (Options[_node_one] == newItems[item]) { //Check if we found a new item
                                if (typeof this.Items[this.ItemTypes[type]][Options[_node_one]] == 'object') { //If the item is a object
                                    for (var values in this.Items[this.ItemTypes[type]][Options[_node_one]]) { //Loop through and get all of the variables from it
                                        SavedValues.push(this.Items[this.ItemTypes[type]][Options[_node_one]][values]); //Push the variables found to SavedValues
                                    }
                                }
                                else {
                                    SavedValues.push(this.Items[this.ItemTypes[type]][Options[_node_one]]); //If its not a object push the values to savedValues
                                }
                                if (Number.isInteger(SavedValues[0])) { //Check if it is a number
                                    ColumnBuilder.push(`${Options[_node_one]}`, `INTEGER`);
                                }
                                else if (typeof SavedValues[0] == "string") { //check if it is a string
                                    ColumnBuilder.push(`${Options[_node_one]}`, `TEXT`);
                                }
                                else if (typeof SavedValues[0] == 'boolean') { //Check if it is a boolean
                                    ColumnBuilder.push(`${Options[_node_one]}`, `INTEGER`);
                                }
                                CurrentItem.AddOptions(Options[_node_one], SavedValues); //Add the options to the Item
                            }
                        }
                    }
                    this.ItemDataArray.push(CurrentItem); //Push the Item to the Itemdataarray and restart
                }
                this.Column = ColumnBuilder; //Format for columnbuilder is: 0 = AutoGenerated SKU 1 = first Built column 2 = column definition 3 = second column 4 = column definition
                // so the to use columnbuild you need a for(let i = 1; i < ColumnBuilder.length; i += 2)
                // This alllows you to skip over the auto generated and access the columns. to get the deinitions you just need to add 1 to the index
                /*
                *   Build or Alter the Table with the options
                */
                var Dot = this.AutoGeneratedClassColumn == "" ? "" : ", ";
                var TableColumn = this.Column[0];
                if (result.length == 0) { //If no table exist
                    for (let i = 1; i < this.Column.length; i += 2) {
                        TableColumn += `${Dot}${this.Column[i]} ${this.Column[i + 1]}`;
                    }
                    this.DBController.createTable(this.TableName, this.ClassName, TableColumn).then((result) => {
                    });
                }
                else { //If we are updating a existing table
                    var newItemArray = [];
                    var Check = true;
                    for (let j = 0; j < newItems.length; j++) { //This section is just to double check these are new items, we will also need to find items to ..
                        for (let i = 1 + this.CACIndex; i < result.length; i++) { //    delete in the future
                            if (result[i].name == newItems[j]) {
                                Check = false;
                                break;
                            }
                            if (i == result.length - 1) {
                                if (Check == true) {
                                    var leave = false;
                                    for (var item in newItemArray) {
                                        if (newItemArray[item] === newItems[j]) {
                                            leave = true;
                                        }
                                    }
                                    if (leave) {
                                        break;
                                    }
                                    newItemArray.push(newItems[j]);
                                }
                            }
                        }
                    }
                    if (newItemArray.length > 0) {
                        for (var item in newItemArray) {
                            for (let i = 1; i < this.Column.length; i += 2) {
                                if (newItemArray[item] == this.Column[i]) {
                                    this.DBController.updateTable(this.TableName, `${this.Column[i]} ${this.Column[i + 1]}`);
                                }
                            }
                        }
                    }
                }
            });
        });
    }
    /*
    *   Called in constructor of child class. Starts the watch event for the file
    *   Calls a callback to handle changes to file
    */
    ParseJson(FilePath, callback) {
        let ParsedData;
        try {
            let rawdata = readFileSync(FilePath);
            ParsedData = JSON.parse(rawdata.toString());
            callback(ParsedData);
        }
        catch (e) {
            console.log(`Error: ${e} | @${FilePath}`);
            return;
        }
        watchFile(FilePath, {
            bigint: false,
            persistent: true,
            interval: 500,
        }, (curr, prev) => {
            try {
                let rawdata = readFileSync(FilePath);
                let ParsedData = JSON.parse(rawdata.toString());
                callback(ParsedData); //Callback to handle changes after
            }
            catch (e) {
                console.log(`Error: ${e} | @${FilePath}`);
            }
        });
    }
}
export { ResponseHandler };
